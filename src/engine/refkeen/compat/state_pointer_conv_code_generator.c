/* Reads a textual file, for which each line has the following format:
 *
 * <ptr> <var_name>
 *
 * where ptr is a 4-digit hexadecimal number (including leading zeros)
 * representing an offset into the dseg, in a 16-bit DOS program,
 * and var_name is the name of a variable (of type statetype).
 *
 * By toggling on the GENERATE_FARPTR_MAPPINGS macro below, ptr
 * can alternatively represent a 32-bit far pointer. This is done
 * for The Catacomb Armageddon v1.02 and The Catacomb Apocalypse v1.01.
 *
 * WARNING: THIS PROGRAM MAY FAIL TO WORK AS EXPECTED AND REPLACE MORE OR LESS
 * THAN INTENDED (Hint: It does replace more than intended, check comments).
 *
 * THIS PROGRAM COMES WITH NO WARRANTY, EXPRESSED OR IMPLIED.
 */

#include <ctype.h>
#include <stdio.h>

// Enable this to handle 32-bit far pointers
//#define GENERATE_FARPTR_MAPPINGS 1

#ifdef GENERATE_FARPTR_MAPPINGS
#define NUM_OF_INPUT_ADDRESS_CHARS 9 // Includes colon in e.g., 1800:0000
#define NUM_OF_HEXDIGITS_STR "8" // 8 digits for the contents of a far pointer
#else
#define NUM_OF_INPUT_ADDRESS_CHARS 4
#define NUM_OF_HEXDIGITS_STR "4"
#endif

#define MAX_MAPPINGS_AMOUNT 500
#define VAR_NAME_LENGTH_UPPER_BOUND 32

typedef struct {
	unsigned int dosptr;
	char varName[VAR_NAME_LENGTH_UPPER_BOUND];
} MapEntry;

int main(int argc, char **argv) {
	//
	MapEntry mappingTable[MAX_MAPPINGS_AMOUNT];
	//
	if (argc != 2) {
		printf("\nThis program expects input map of ");
#ifdef GENERATE_FARPTR_MAPPINGS
		printf("32-bit far ");
#else
		printf("16-bit near ");
#endif
		printf("state pointers\nto state variable names. Outputs generated code to stdout.\n");
		return 1;
	}
	FILE *fp = fopen(argv[1], "rb");
	if (!fp) {
		printf("\nFile %s cannot be opened for reading\n", argv[1]);
		return 2;
	}
	int mapCounter = 0, readVal, i;
	MapEntry *currEntry = mappingTable;
	while (!feof(fp) && (mapCounter < MAX_MAPPINGS_AMOUNT)) {
		// Scan DOS-era pointer (16-bit offset/near pointer or 32-bit far pointer)
		currEntry->dosptr = 0;
		for (i = 0; i < NUM_OF_INPUT_ADDRESS_CHARS; ++i) {
			readVal = fgetc(fp);
			if (readVal == EOF) {
				break;
			}
#ifdef GENERATE_FARPTR_MAPPINGS
			if (i == 4) { // Colon in e.g., 1800:0000
				if (readVal != ':') {
					fclose(fp);
					fprintf(stderr, "\nFATAL ERROR: Line no. %d doesn't begin with a proper address, aborting\n", mapCounter);
					return 3;
				}
				continue;
			}
#endif
			if ((readVal >= '0') && (readVal <= '9')) {
				currEntry->dosptr = 16*(currEntry->dosptr) + readVal-'0';
			} else if ((readVal >= 'A') && (readVal <= 'F')) {
				currEntry->dosptr = 16*(currEntry->dosptr) + readVal-'A'+10;
			} else if ((readVal >= 'a') && (readVal <= 'f')) {
				currEntry->dosptr = 16*(currEntry->dosptr) + readVal-'a'+10;
			} else {
				fclose(fp);
				fprintf(stderr, "\nFATAL ERROR: Line no. %d doesn't begin with a proper address, aborting\n", mapCounter);
				return 3;
			}
		}
		if (readVal == EOF) {
			break;
		}
		// Skip whitespace
		do {
			readVal = fgetc(fp);
		} while (isspace(readVal));
		// Scan variable name - USING LAST readVal VALUE FROM ABOVE
		int varNameLen = 0;
		char *varNamePtr = currEntry->varName;
		do {
			if ((readVal == EOF) || isspace(readVal)) {
				break;
			}
			*(varNamePtr++) = readVal;
			if (++varNameLen == VAR_NAME_LENGTH_UPPER_BOUND)
			{
				fclose(fp);
				*(varNamePtr-1) = '\0'; // For printing
				fprintf(stderr, "\nFATAL ERROR: Too long variable nameFile (beginning with %s, line no. %d), aborting\n", currEntry->varName, mapCounter);
				return 4;
			}
			readVal = fgetc(fp);
		} while (1);
		// DON'T FORGET THESE!
		*varNamePtr = '\0';
		++mapCounter;
		++currEntry;
		// Scan until we encounter newline (line feed)
		while ((readVal != '\n') && (readVal != EOF)) {
			readVal = fgetc(fp);
		}
		if (readVal == EOF) {
			fprintf(stderr, "\nWARNING: Encountered end-of-file before newline, this may be considered acceptable in other programs.\n");
		}
	}
	if (!feof(fp)) {
		fclose(fp);
		fprintf(stderr, "\nFATAL ERROR: Too many lines in input file (max. supported %d), aborting.\n", MAX_MAPPINGS_AMOUNT);
	}
	/*** Finally we can print our output ***/
	printf("/*** Code generated by state_pointer_conv_code_generator ***/\n");
	printf("\n");
	printf("#include \"kd_def.h\"\n");
	printf("\n");
#ifdef GENERATE_FARPTR_MAPPINGS
	printf("// The exact segment of a 32-bit far pointer depends on location of DOS EXE\n");
	printf("// in memory, so make it possible to configure it\n");
	printf("static uint_fast32_t g_farPtrExeLocSegOffset;\n");
	printf("\n");
#endif
	// First declare variables with extern
	printf("// List of all states\n");
	for (i = 0, currEntry = mappingTable; i < mapCounter; ++i, ++currEntry) {
		printf("extern statetype %s;\n", currEntry->varName);
	}
	// We then write function that fills each such state's new field with the original 16-bit pointer
	printf("\n");
	printf("void BE_Cross_Compat_FillObjStatesWithDOSPointers(void)\n");
	printf("{\n");
#ifdef GENERATE_FARPTR_MAPPINGS
	printf("\tg_farPtrExeLocSegOffset = ((uint_fast32_t)BE_Cross_Compat_GetFarPtrRelocationSegOffset()) * 0x10000;\n");
#endif
	for (i = 0, currEntry = mappingTable; i < mapCounter; ++i, ++currEntry) {
		printf("\t%s.compatdospointer = 0x%0" NUM_OF_HEXDIGITS_STR "X", currEntry->varName, (unsigned int)(currEntry->dosptr));
#ifdef GENERATE_FARPTR_MAPPINGS
		printf(" + g_farPtrExeLocSegOffset");
#endif
		printf(";\n");
	}
	printf("}\n");
	// Finally we write a method for conversion of DOS pointer to native state pointer (for saved game loading);
	// Returns NULL if not found (which can happen if the saved value hasn't been used as a state)
	printf("\n");
	printf("void* BE_Cross_Compat_GetObjStatePtrFromDOSPointer(uint_fast32_t dosptr)\n");
	printf("{\n");
#ifdef GENERATE_FARPTR_MAPPINGS
	printf("\tswitch (dosptr - g_farPtrExeLocSegOffset)\n");
#else
	printf("\tswitch (dosptr)\n");
#endif
	printf("\t{\n");
	for (i = 0, currEntry = mappingTable; i < mapCounter; ++i, ++currEntry) {
		printf("\tcase 0x%0" NUM_OF_HEXDIGITS_STR "X: return &%s;\n", (unsigned int)(currEntry->dosptr), currEntry->varName);
	}
	printf("\t}\n");
	printf("\treturn NULL;\n");
	printf("}\n");
	return 0;
}
